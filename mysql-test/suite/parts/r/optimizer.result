drop table if exists t1,t2;
#
# Bug#50939: Loose Index Scan unduly relies on engine to remember range 
# endpoints
#
CREATE TABLE t1 (
a INT,
b INT,
KEY ( a, b )
) PARTITION BY HASH (a) PARTITIONS 1;
CREATE TABLE t2 (
a INT,
b INT,
KEY ( a, b )
);
INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3), (4, 4), (5, 5);
INSERT INTO t1 SELECT a +  5, b +  5 FROM t1;
INSERT INTO t1 SELECT a + 10, b + 10 FROM t1;
INSERT INTO t1 SELECT a + 20, b + 20 FROM t1;
INSERT INTO t1 SELECT a + 40, b + 40 FROM t1;
INSERT INTO t2 SELECT * FROM t1;
# plans should be identical
EXPLAIN SELECT a, MAX(b) FROM t1 WHERE a IN (10,100) GROUP BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a	a	5	NULL	2	Using where; Using index
EXPLAIN SELECT a, MAX(b) FROM t2 WHERE a IN (10,100) GROUP BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	a	a	5	NULL	2	Using where; Using index
FLUSH status;
SELECT a, MAX(b) FROM t1 WHERE a IN (10, 100) GROUP BY a;
a	MAX(b)
10	10
# Should be no more than 4 reads.
SHOW status LIKE 'handler_read_key';
Variable_name	Value
Handler_read_key	2
FLUSH status;
SELECT a, MAX(b) FROM t2 WHERE a IN (10, 100) GROUP BY a;
a	MAX(b)
10	10
# Should be no more than 4 reads.
SHOW status LIKE 'handler_read_key';
Variable_name	Value
Handler_read_key	2
DROP TABLE t1, t2;
#
# MDEV-28509: Access null pointer during add_key_field call
#
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (1),(2),(3);
WITH cte AS (SELECT i FROM (SELECT i FROM t1 GROUP BY i) dt WINDOW w AS (PARTITION BY i))
SELECT a.i FROM cte a JOIN cte b on a.i=b.i WHERE a.i != 5;
i
1
2
3
DROP TABLE t1;
WITH c AS (SELECT i FROM (SELECT i FROM (SELECT 1 AS i) AS i GROUP BY i) d WINDOW w AS (PARTITION BY i)) SELECT a.i FROM c a JOIN c b on a.i=b.i WHERE a.i!=1;
i
CREATE TABLE t2 ( v1055 INT );
INSERT INTO t2 ( v1055 ) VALUES ( 54 );
UPDATE t2 SET v1055 = 127 WHERE v1055 = 83;
INSERT INTO t2 ( v1055 ) VALUES ( -1 ) , ( -1 );
WITH v1057 AS ( SELECT v1055 FROM ( SELECT v1055 FROM t2 GROUP BY v1055 ) AS v1056 ) SELECT v1055 FROM v1057 WHERE v1055 BETWEEN FALSE AND ( ( ( v1055 OR NOT v1055 ) BETWEEN ( ( ( ( EXISTS ( WITH v1063 AS ( SELECT v1055 FROM ( SELECT v1055 FROM t2 GROUP BY v1055 ) AS v1058 WINDOW v1062 AS ( PARTITION BY v1055 ORDER BY ( SELECT DISTINCT 16 FROM t2 AS v1059 , t2 AS v1060 , t2 AS v1061 JOIN t2 ) DESC RANGE BETWEEN 80808358.000000 FOLLOWING AND 82012945.000000 FOLLOWING ) ) SELECT v1055 FROM ( SELECT DISTINCT ( ( NOT ( 60914711.000000 AND v1055 = 68 ) ) = -1 AND v1055 = 17 ) % v1055 , ( v1055 = -1 OR v1055 > 'x' ) FROM t2 WHERE v1055 = -128 AND ( v1055 = -128 OR v1055 = 0 OR v1055 = 31 ) ) AS v1064 NATURAL JOIN v1063 AS v1065 NATURAL JOIN v1063 AS v1066 NATURAL JOIN ( SELECT DISTINCT v1055 , ( v1055 = -1 OR v1055 > 'x' ) FROM t2 ) AS v1067 NATURAL JOIN v1063 AS v1068 NATURAL JOIN v1063 WHERE v1055 != 72 GROUP BY v1055 ORDER BY v1055 ) AND v1055 = -1 ) - 2147483647 ) ) ) AND 'x' = ( 4 + 34235093.000000 <= 60 ) ) );
v1055
Warnings:
Warning	1292	Truncated incorrect DECIMAL value: 'x'
Warning	1292	Truncated incorrect DECIMAL value: 'x'
DROP TABLE t2;
