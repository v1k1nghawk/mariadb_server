# The server must support partitioning.
--source include/have_partition.inc

--disable_warnings
drop table if exists t1,t2;
--enable_warnings

--echo #
--echo # Bug#50939: Loose Index Scan unduly relies on engine to remember range 
--echo # endpoints
--echo #
CREATE TABLE t1 (
 a INT,
 b INT,
 KEY ( a, b )
) PARTITION BY HASH (a) PARTITIONS 1;

CREATE TABLE t2 (
 a INT,
 b INT,
 KEY ( a, b )
);

INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3), (4, 4), (5, 5);

INSERT INTO t1 SELECT a +  5, b +  5 FROM t1;
INSERT INTO t1 SELECT a + 10, b + 10 FROM t1;
INSERT INTO t1 SELECT a + 20, b + 20 FROM t1;
INSERT INTO t1 SELECT a + 40, b + 40 FROM t1;

INSERT INTO t2 SELECT * FROM t1;

--echo # plans should be identical
EXPLAIN SELECT a, MAX(b) FROM t1 WHERE a IN (10,100) GROUP BY a;
EXPLAIN SELECT a, MAX(b) FROM t2 WHERE a IN (10,100) GROUP BY a;

--disable_ps2_protocol
FLUSH status;
SELECT a, MAX(b) FROM t1 WHERE a IN (10, 100) GROUP BY a;
--echo # Should be no more than 4 reads.
SHOW status LIKE 'handler_read_key';

FLUSH status;
SELECT a, MAX(b) FROM t2 WHERE a IN (10, 100) GROUP BY a;
--echo # Should be no more than 4 reads.
SHOW status LIKE 'handler_read_key';
--enable_ps2_protocol

DROP TABLE t1, t2;

--echo #
--echo # MDEV-28509: Access null pointer during add_key_field call
--echo #
CREATE TABLE t1 (i int);
INSERT INTO t1 VALUES (1),(2),(3);
WITH cte AS (SELECT i FROM (SELECT i FROM t1 GROUP BY i) dt WINDOW w AS (PARTITION BY i))
SELECT a.i FROM cte a JOIN cte b on a.i=b.i WHERE a.i != 5;
DROP TABLE t1;

WITH c AS (SELECT i FROM (SELECT i FROM (SELECT 1 AS i) AS i GROUP BY i) d WINDOW w AS (PARTITION BY i)) SELECT a.i FROM c a JOIN c b on a.i=b.i WHERE a.i!=1;

CREATE TABLE t2 ( v1055 INT );
INSERT INTO t2 ( v1055 ) VALUES ( 54 );
UPDATE t2 SET v1055 = 127 WHERE v1055 = 83;
INSERT INTO t2 ( v1055 ) VALUES ( -1 ) , ( -1 );
WITH v1057 AS ( SELECT v1055 FROM ( SELECT v1055 FROM t2 GROUP BY v1055 ) AS v1056 ) SELECT v1055 FROM v1057 WHERE v1055 BETWEEN FALSE AND ( ( ( v1055 OR NOT v1055 ) BETWEEN ( ( ( ( EXISTS ( WITH v1063 AS ( SELECT v1055 FROM ( SELECT v1055 FROM t2 GROUP BY v1055 ) AS v1058 WINDOW v1062 AS ( PARTITION BY v1055 ORDER BY ( SELECT DISTINCT 16 FROM t2 AS v1059 , t2 AS v1060 , t2 AS v1061 JOIN t2 ) DESC RANGE BETWEEN 80808358.000000 FOLLOWING AND 82012945.000000 FOLLOWING ) ) SELECT v1055 FROM ( SELECT DISTINCT ( ( NOT ( 60914711.000000 AND v1055 = 68 ) ) = -1 AND v1055 = 17 ) % v1055 , ( v1055 = -1 OR v1055 > 'x' ) FROM t2 WHERE v1055 = -128 AND ( v1055 = -128 OR v1055 = 0 OR v1055 = 31 ) ) AS v1064 NATURAL JOIN v1063 AS v1065 NATURAL JOIN v1063 AS v1066 NATURAL JOIN ( SELECT DISTINCT v1055 , ( v1055 = -1 OR v1055 > 'x' ) FROM t2 ) AS v1067 NATURAL JOIN v1063 AS v1068 NATURAL JOIN v1063 WHERE v1055 != 72 GROUP BY v1055 ORDER BY v1055 ) AND v1055 = -1 ) - 2147483647 ) ) ) AND 'x' = ( 4 + 34235093.000000 <= 60 ) ) );
DROP TABLE t2;
